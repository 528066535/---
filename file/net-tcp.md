
    盗用了自己两年前写的文章。

### 一. TCP

 TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，
 确保对方按顺序收到，如果包丢掉了，就自动重发。许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。
 一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。

### 二. 三次握手和四次握手

 #### 三次握手建立连接

 过程如下图所示。

 ![layout viewport](/img/tcp-1.gif)

 SYN包：连接用的包。

 Seq包：可以看出来发包的顺序。第一次随机产生客户端的X位置。第二次产生服务器端Y的位置。第三次表示我把X+1开始的位置发过去了。

 Ack：应答包，意思是我收到了。第一次为0，第二次，意思是服务器说我下次我可以收X+1的位置的数据了。第三次意思是，客户端说下次我可以收到你Y+1位置开始的数据了。

 #### 四次握手断开连接

 过程如下图所示。

 ![layout viewport](/img/tcp-2.webp)

 FIN表示断开连接的包。

 当然，当客户端和服务器三次握手后建立长连接的时候就不需要经过三次握手来互相通信了，只需要两次，客户端发给服务器一个包，服务器答复客户端一个包。

### 三. TCP 相关知识

 #### 滑动窗口机制

 说到滑动窗口，需要理解两个概念，一个是应答机制，一个是缓冲区，一条数据成功发送的过程是这样的，A把数据放到自己的发送缓冲区，发送缓冲区保留了这条数据，
 然后把这条数据发送给B的接受缓冲区，B接受到这条数据后回返回给A一个ACK包，表示B收到了，A再把缓冲区里面的刚发送成功的数据清空，这就是一条数据正常发送的过程。

 它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，
 那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来。

 注意：当B的缓冲区满的时候，A就不能再次发送数据了。当由于网络等原因B没有收到A发的数据时，A会用重发机制，把缓存里面的数据重新发送一遍。

 #### 拥塞控制

 有没有发现每次用socket的时候，发送数据的大小会渐渐变大，这是因为TCP的拥塞控制。计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。
 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，
 这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。

 发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，
 另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

 ![layout viewport](/img/tcp-3.webp)

 ![layout viewport](/img/tcp-4.webp)

 当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。

 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：

 当condo<ssthresh时，使用慢算法。

 当cwnd>ssthresh时，改用拥塞避免算法。

 当cwnd=ssthresh时，慢开始与拥塞避免算法任意。

 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，
 但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。
